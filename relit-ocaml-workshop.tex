\PassOptionsToPackage{svgnames,dvipsnames,svgnames}{xcolor}
%% For double-blind review submission
%\documentclass[acmsmall,review]{acmart}
%%% Note: arxiv does not want line numbers (they are detected somehow, and are not allowed)
\documentclass[acmsmall,review]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
\settopmatter{printccs=false,printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column

%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.

% \bibliographystyle{ACM-Reference-Format}


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

%% Cyrus packages
\usepackage{microtype}
\usepackage{mdframed}
\usepackage{colortab}
\usepackage{mathpartir}
\usepackage{enumitem}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{leftidx}
\usepackage{todonotes}
\usepackage{xspace}
\usepackage{wrapfig}


%% Listings
\definecolor{mygray}{rgb}{0.75,0.75,0.75}
\usepackage{listings}
\lstset{tabsize=2, 
basicstyle=\ttfamily\fontsize{8pt}{1em}\selectfont, 
commentstyle=\itshape\ttfamily\color{gray},
stringstyle=\ttfamily\color{purple},
mathescape=false,escapeinside={(~}{~)},
numbers=left, numberstyle=\scriptsize\color{mygray}, language=ML,showspaces=false,showstringspaces=false,xleftmargin=0pt, numbersep=-6pt, morekeywords=[1]{try,spliced,tyfam,opfam,let,fn,val,def,casetype,objtype,metadata,of,*,string,lexer,parser,datatype,new,toast,notation,module,switch,where,expansions,require,import,for,ana,syn,opcon,tycon,metasignature,metamodule,metasig,metamod,static,at,by,tycase,mod,macro,match,pattern,in,patterns,expressions,implicit,forall,int,exptsm,pattsm,dependencies},deletekeywords={double,structure,of},classoffset=0, xleftmargin=0pt, 
aboveskip=3pt,belowskip=2pt,
moredelim=**[is][\color{red}]{SSTR}{ESTR},
moredelim=**[is][\color{Periwinkle}]{SHTML}{EHTML},
moredelim=**[is][\color{purple}]{SCSS}{ECSS},
moredelim=**[is][\color{brown}]{SSQL}{ESQL},
moredelim=**[is][\color{orange}]{SCOLOR}{ECOLOR},
moredelim=**[is][\color{magenta}]{SPCT}{EPCT}, 
moredelim=**[is][\color{gray}]{SNAT}{ENAT}, 
moredelim=**[is][\color{Periwinkle}]{SURL}{EURL},
moredelim=**[is][\color{Sealavender}]{SQT}{EQT},
moredelim=**[is][\color{Periwinkle}]{SGRM}{EGRM},
moredelim=**[is][\color{Yellowlavender}]{SID}{EID},
moredelim=**[is][\color{Sepia}]{SUS}{EUS},
moredelim=**[is][\color{black}]{SOK}{EOK},
% deletestring=[d]{"},
}
\lstset{morecomment=[n]{/*}{*/}}

\newcommand{\liv}[1]{\lstinline{#1}}
\newcommand{\li}[1]{\lstinline[basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont]{#1}}
\newcommand{\lismall}[1]{\lstinline[basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont]{#1}}
\newcommand{\lifootnote}[1]{\lstinline[basicstyle=\ttfamily\fontsize{7pt}{1em}\selectfont]{#1}}


%% Joshua Dunfield macros
\def\OPTIONConf{1}%
\usepackage{joshuadunfield}

%% Can remove this eventually
\usepackage{blindtext}

\usepackage{enumitem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Matt says: Cyrus, this package `adjustbox` seems directly related
%% to the `clipbox` error; To get rid of the error, I moved it last
%% (after other usepackages) and I added the line just above it, which
%% permits it to redefine `clipbox` (apparently also defined in
%% `pstricks`, and due to latex's complete lack of namespace
%% management, these would otherwise names clash).
\let\clipbox\relax
\usepackage[export]{adjustbox}% http://ctan.org/pkg/adjustbox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{draftwatermark}
%\SetWatermarkText{DRAFT}
%\SetWatermarkScale{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% A macro for the name of the system being described by ``this paper''
\newcommand{\HazelnutLive}{\textsf{Hazelnut Live}\xspace}
\newcommand{\Hazelnut}{\textsf{Hazelnut}\xspace}
% The mockup, work-in-progress system.
\newcommand{\Hazel}{\textsf{Hazel}\xspace}

% \newtheorem{theorem}{Theorem}[chapter]
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{assumption}[theorem]{Assumption}
% \newtheorem{condition}[theorem]{Condition}

\newtheoremstyle{slplain}% name
  {.15\baselineskip\@plus.1\baselineskip\@minus.1\baselineskip}% Space above
  {.15\baselineskip\@plus.1\baselineskip\@minus.1\baselineskip}% Space below
  {\slshape}% Body font
  {\parindent}%Indent amount (empty = no indent, \parindent = para indent)
  {\bfseries}%  Thm head font
  {.}%       Punctuation after thm head
  { }%      Space after thm head: " " = normal interword space;
        %       \newline = linebreak
  {}%       Thm head spec
\theoremstyle{slplain}
\newtheorem{thm}{Theorem}  % Numbered with the equation counter
\numberwithin{thm}{section}
\newtheorem{defn}[thm]{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
% \newtheorem{cor}[section]{Corollary}     
% \newtheorem{lem}[section]{Lemma}         
% \newtheorem{prop}[section]{Proposition}  

% \setlength{\abovedisplayskip}{0pt}
% \setlength{\belowdisplayskip}{0pt}
% \setlength{\abovedisplayshortskip}{0pt}
% \setlength{\belowdisplayshortskip}{0pt}



\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2018}
\acmMonth{3}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
% \acmConference[]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}

\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


\fancyfoot{} % suppresses the footer (also need \thispagestyle{empty} after \maketitle below)


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\input{commands}
\input{macros}

\setlength{\abovecaptionskip}{4pt plus 3pt minus 2pt} % Chosen fairly arbitrarily
\setlength{\belowcaptionskip}{-4pt plus 3pt minus 2pt} % Chosen fairly arbitrarily


\begin{document}

%% Title information
\title{Relit: Implementing Typed Literal Macros in Reason}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Charles Chamberlain}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Chicago}            %% \institution is required
  % \streetaddress{Street1 Address1}
  % \city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  % \country{Country1}
}
\email{cchamberlain@uchicago.edu}          %% \email is recommended

\author{Cyrus Omar}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Chicago}            %% \institution is required
  % \streetaddress{Street1 Address1}
  % \city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  % \country{Country1}
}
\email{comar@cs.uchicago.edu}          %% \email is recommended

% %% Author with two affiliations and emails.
% \author{First2 Last2}
% \authornote{with author2 note}          %% \authornote is optional;
%                                         %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
% \affiliation{
%   \position{Position2a}
%   \department{Department2a}             %% \department is recommended
%   \institution{Institution2a}           %% \institution is required
%   \streetaddress{Street2a Address2a}
%   \city{City2a}
%   \state{State2a}
%   \postcode{Post-Code2a}
%   \country{Country2a}
% }
% \email{first2.last2@inst2a.com}         %% \email is recommended
% \affiliation{
%   \position{Position2b}
%   \department{Department2b}             %% \department is recommended
%   \institution{Institution2b}           %% \institution is required
%   \streetaddress{Street3b Address2b}
%   \city{City2b}
%   \state{State2b}
%   \postcode{Post-Code2b}
%   \country{Country2b}
% }
% \email{first2.last2@inst2b.org}         %% \email is recommended


%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
% \thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\input{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
% \keywords{keyword1, keyword2, keyword3}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle
\thispagestyle{empty} % suppresses the footer

\section{Motivation}

The Reason project (\url{https://reasonml.github.io/}) is experiencing growing adoption by focusing on increasing the \emph{syntactic familiarity} of OCaml (from the perspective of the broader developer community) without changing its semantics. The focus of the Reason effort so far has been on the syntax of the primitive constructs of OCaml. However, another way to increase syntactic familiarity is by introducing new {literal forms} for constructing and pattern matching on  common user-defined data structures. For example, both OCaml and Reason include literal forms for lists, e.g. \li{[e1, e2, e3]} in Reason, which lay out the list elements in the familiar sequential, punctuation-separated format. By comparison, explicitly applying constructors, e.g. \li{Nil} and \li{Cons}, is both more verbose and less familiar to human programmers.

The problem is that there are an  unbounded number of other user-defined data structures that could benefit from literal notation. Although Reason does include a few more literal notations than OCaml, e.g. it supports ``JSX literals'' which are based on HTML \cite{JSX}, it would be infeasible for Reason to attempt to build in all possibly-useful literal notations \emph{a priori}. Instead, there has been a need for a reasonable mechanism that allows ordinary library providers to define new literal notation for their own data structures.

For example, consider the recursive datatype \li{Regex.t}, defined in Fig.~\ref{fig:Regex-module-def}, which encodes simple regular expressions (regexes). Although this encoding is semantically useful, the induced notation is syntactically verbose and unfamiliar. For example, we would construct a regex that matches the strings \li{"A"}, \li{"T"}, \li{"G"} or \li{"C"}, which represent the four bases in DNA, as follows:
\begin{lstlisting}[numbers=none]
  module DNA = { 
    let any_base = Regex.(Or(Str "A", Or(Str "T", Or(Str "G", Or(Str "C")))))
  }
\end{lstlisting}
From there, we might define a regular expression that matches the DNA sequences recognized by the BisA restriction enzyme --- \li{GC}$X$\li{GC}, where $X$ is any of these four bases --- as follows:
\begin{lstlisting}[numbers=none]
  let bisA = Regex.(Seq(Str "G", Seq(Str "C", 
                    Seq(DNA.any_base, Seq(Str "G", Str "C")))))
\end{lstlisting}

If we built regex literals into Reason, based on the POSIX standard regular expression notation extended with support for constructing regexes compositionally by splicing in expressions of type \li{Regex.t} delimited by \li{$(} and \li{)}, these examples would be substantially more concise and familiar to contemporary programmers:
\begin{lstlisting}[numbers=none]
  module DNA = { let any_base = `(SURLA|T|G|CEURL)` };
  let bisA = `(SURLGC$(EURLDNA.any_baseSURL)GCEURL)`
\end{lstlisting}

However, building regex notation for this particular encoding of regexes is, we argue, rather \emph{ad hoc} --- there are dozens of other examples of notation in programming, mathematics and science that could similarly benefit \cite{cites,from,paper}. 

An alternative is to use a tool like \li{camlp4} or \li{ppx} to introduce this sort of literal notation modularly. There are several problems with these tools, however. Omar et al. \cite{TLMs-paper} details the problems, but to briefly summarize, these systems lack the ability to reason abstractly---without looking at the underlying expansion itself, or the parsing and expansion logic---about responsibility (which extension is uniquely responsible for each form?), typing (what type does a new form have?) and binding (where are variables bound, given that the expansion is not visible?)

To address this problem, Omar et al. \cite{TLMs-paper} introduced \emph{typed literal macros (TLMs)}. An example of a TLM definition for regex notation, named \li{$regex}, is given in Fig.~\ref{fig:regex-tlm-def}. We can apply this TLM  

\begin{figure}[t]
\begin{subfigure}[t]{0.45\textwidth}
\vspace{-1px}
\begin{lstlisting}[mathescape=~]
  module Regex = {
    type t = 
      | Empty
      | AnyChar 
      | Str(string)
      | Seq(t, t) 
      | Or(t, t) 
      | Star(t);
  }
\end{lstlisting}
\vspace{-5px}
\caption{The \li{Regex} module, which defines the recursive datatype \li{Regex.t}.}
\label{fig:Regex-module-def}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.53\textwidth}
\vspace{-1px}
\begin{lstlisting}[mathescape=|]
  module RegexNotation = {
    notation $regex at Regex.t {
      lexer  RegexLexer and 
      parser RegexParser.start
      in regex_parser;
      dependencies = 
        { module Regex = Regex; }
    }
  }
\end{lstlisting}
\vspace{-5px}
\caption{The definition of the \li{$regex} TLM (the lexer and parser is detailed in \cite{TLMs-paper}).}
\label{fig:regex-tlm-def}
\end{subfigure}

\begin{subfigure}[t]{\textwidth}
\vspace{5px}
\begin{lstlisting}
  notation $regex = RegexNotation.$regex; /* or open RegexNotation */
  module DNA = { let any_base = $regex `(SURLA|T|G|CEURL)`; };
  let bisA = $regex `(SURLGC$(EURLDNA.any_baseSURL)GCEURL)`;
\end{lstlisting}
\vspace{-4px}
\caption{Examples of the \li{$regex} TLM being applied in a bioinformatics application. %In each case, literal body, between backticks, is initially left unparsed according to the language's context-free syntax. %The applied TLM determines a segmentation and expansion during the typed expansion phase, which generalizes the usual typing phase.
}
\label{fig:first-tlm-example}
\end{subfigure}
\vspace{5px}
\caption{Case Study (reproduced from \cite{TLMs-paper}): POSIX-style regex literal notation, with support for regex splicing.}
% \vspace{-6px}
\label{fig:regex-case-study}
\end{figure}

Motivation similar to that in the ICFP paper -- but compare more explicitly to how people use ppx to rewrite string literals to support notation, camlp4, and Reason's built in HTMLish notation.

\section{Implementation}

We have modified the Reason parser to support the syntax for defining a new notation, seen in Fig.~\ref{fig:regex-tlm-def}, and the TLM quotation syntax, either \li{`(body)`} or \li{Path.To.$regex `(body)`}.

We parse the \li{$regex} notation in Fig.~\ref{fig:regex-tlm-def} into an OCaml \li{Parsetree} equivalent to the following OCaml module:
\begin{lstlisting}
  module RelitInternalDefn_regex = struct
    type t = Regex.t
    module Lexer_RegexParser = struct end
    module Parser_RegexLexer = struct end
    module Package_regex_parser = struct end
    module Nonterminal_literal = struct end
    module Dependencies = struct
      module Regex = Regex
    end
    exception Call of string * string
  end
\end{lstlisting}

The name of the TLM, i.e the \li{regex} in \li{$regex}, is stored as the module name, with an internal prefix. This enables TLMs to be aliased, opened, and qualified by their parent modules. A TLM application is represented as a call to \li{raise} within the OCaml \li{Parsetree} generated by the Reason parser:
\begin{lstlisting}
  raise (RelitInternalDefn_regex.Call
          ("You're using relit syntax without the relit ppx!", "a|b") [@relit])
\end{lstlisting}


This passes the body of the TLM application on to the next stage of compilation --- the Relit PPX. It also provides a meaningful error message to any users of a Relit notation that forget to use the Relit PPX. The Relit PPX starts by running the OCaml typechecker. Then it maps over the resulting \li{Typedtree}, searching for all TLM applications. Every node of this typed tree has a typing environment which contains the modules, variables, record fields in scope, and their types or signatures. So to resolve the TLM definition for a given application, the PPX looks up the prefixed module name (in this case \li{RelitInternalDefn_regex}) in the application's typing environment to find its signuatere. This is why we encode the data for the lexer, the parser, their package, and the starting nonterminal as module names; it can be read from the signature of the notation's module without having access to the module's definition itself.

This method of finding the module through the typing environment results in a strange paradox: We must typecheck before we've expanded the TLM application, even before we have access to its expected type. This is where the \li{raise} call becomes important. Raising an exception matches against every type, so it will typecheck without an issue before it is expanded fully.

At this point, the PPX has all the information for a given call site that it needs --- the TLM body, the names of the parser and lexer --- so it runs the parser and lexer on the TLM body. As TLMs are macros, albeit specialized ones, they require running code at compile time. Specifically, TLMs involve running the provide parser and lexer, modules that {\it are not available when the PPX itself is compiled}. Our first attempt involved starting an OCaml toplevel within the PPX, \li{#load}-ing the appropriate OCaml object files, and then evaluating a call to the parser. This proved more difficult when the parser and lexer themselves had dependencies. The current implementation instead generates an OCaml file with calls to the parser and lexer, builds it with \li{ocamlfind ocamlc}, and runs the resulting \li{.byte} file to get a marshalled parse tree from standard output. We require that the parser and lexer be in their own OCamlfind package, which is the package specified in the \li{notation} syntax. This ensures that not only are the parser and lexer loaded, but all their dependencies are as well.

After running the provided parser against the TLM body, we are left with a proto-expansion --- an OCaml parsetree that has unexpanded splices. The next step is a check to make sure these expressions are context independent: the proto-expansions must not refer to variables or modules accessible in the application context. We first check there are no free variables by simply running the typechecker aginst the proto-expansion, with an empty typing environment. (We do add in the dependencies which were explicitely allowed in the \li{notation} definition.) One might think this strategy would work to check modules too, but there is a global list of top-level modules that the typechecker allows, even when typing against an empty environment. So the PPX has an OCaml \li{Parsetree} and it wants to make sure that the free modules it uses (the parsetree can define its own modules internally) are restricted to the supplied dependencies. The solution we came up with is to write this \li{Parsetree} to a file, and run \li{ocamldep -modules} against the file. This gives us exactly a list of free modules, which we check against the dependencies, resulting in a completely context independent proto-expansion.

It is still a proto-expansion since there are splices which the TLM parser could have potentially outputted. It is the PPX's job to parse these splices with the Reason parser and supply the resulting parse trees in a capture-avoiding way.  We have encoded the splices returned from the TLM parser as exceptions, once again. Since we're type checking 
before this to ensure context independence, the intermediate form must pass the typechecker.

\begin{lstlisting}
raise (ignore (2, 4) ; Failure "RelitInternal__Spliced") : string
\end{lstlisting}

finally recurse

\begin{enumerate}
  \item Extending the Reason parser
  \item Using singleton signatures to encode definitions
  \item Using exceptions for application + typechecking inside a PPX (but really we only need to signature check but thats not possible). Is it bad?
  \item Using ocamldep to determine module dependencies
  \item Awkwardness with packaging the parser
  \item Speculation: issues with OCaml + Reason support together (use menhir's parameterization?)
\end{enumerate}
\section{Discussion}
Successes:
\begin{enumerate}
  \item ocamldep was a straightforward way to do context independence
  \item can do typechecking and compile-time code execution in a ppx
\end{enumerate}

Challenges:
\begin{enumerate}
  \item packaging / loading parsers at compile-time is a huge hassle
  \item jbuilder treats ppx differently
  \item ordering of ppx matters
  \item ocamldep can't see into spliced terms -- how to fix?
  \item we need to extend merlin and other tools still...
  \item issues with using OCaml + Reason together
\end{enumerate}

briefly: relationship between this stuff and Scheme/Racket/Scala-style macros

%\clearpage
\bibliography{references,all.short,hazel_NSF}

% \clearpage
% \appendix
% \input{implementation-appendix}

\end{document}
