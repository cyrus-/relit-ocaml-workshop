\PassOptionsToPackage{svgnames,dvipsnames,svgnames}{xcolor}
%% For double-blind review submission
%\documentclass[acmsmall,review]{acmart}
%%% Note: arxiv does not want line numbers (they are detected somehow, and are not allowed)
\documentclass[acmsmall]{acmart}
%\settopmatter{printfolios=false,printccs=false,printacmref=false}
\settopmatter{printccs=false,printacmref=false}
\setcopyright{none}
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column

%% For single-blind review submission
%\documentclass[acmlarge,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission
%\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.

% \bibliographystyle{ACM-Reference-Format}


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

%% Cyrus packages
\usepackage{microtype}
\usepackage{mdframed}
\usepackage{colortab}
\usepackage{mathpartir}
\usepackage{enumitem}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{leftidx}
\usepackage{todonotes}
\usepackage{xspace}
\usepackage{wrapfig}


%% Listings
\definecolor{mygray}{rgb}{0.75,0.75,0.75}
\usepackage{listings}
\lstset{tabsize=2, 
basicstyle=\ttfamily\fontsize{8pt}{1em}\selectfont, 
commentstyle=\itshape\ttfamily\color{gray},
stringstyle=\ttfamily\color{purple},
mathescape=false,escapeinside={(~}{~)},
numbers=left, numberstyle=\scriptsize\color{mygray}, language=ML,showspaces=false,showstringspaces=false,xleftmargin=0pt, numbersep=-6pt, morekeywords=[1]{try,spliced,tyfam,opfam,let,fn,val,def,casetype,objtype,metadata,of,*,string,lexer,parser,datatype,new,toast,notation,module,switch,where,expansions,require,import,for,ana,syn,opcon,tycon,metasignature,metamodule,metasig,metamod,static,at,by,tycase,mod,macro,match,pattern,package,in,patterns,expressions,implicit,forall,int,exptsm,pattsm,dependencies},deletekeywords={with,double,structure},classoffset=0, xleftmargin=0pt, 
aboveskip=3pt,belowskip=2pt,
moredelim=**[is][\color{red}]{SSTR}{ESTR},
moredelim=**[is][\color{Periwinkle}]{SHTML}{EHTML},
moredelim=**[is][\color{purple}]{SCSS}{ECSS},
moredelim=**[is][\color{brown}]{SSQL}{ESQL},
moredelim=**[is][\color{orange}]{SCOLOR}{ECOLOR},
moredelim=**[is][\color{magenta}]{SPCT}{EPCT}, 
moredelim=**[is][\color{gray}]{SNAT}{ENAT}, 
moredelim=**[is][\color{Periwinkle}]{SURL}{EURL},
moredelim=**[is][\color{Sealavender}]{SQT}{EQT},
moredelim=**[is][\color{Periwinkle}]{SGRM}{EGRM},
moredelim=**[is][\color{Yellowlavender}]{SID}{EID},
moredelim=**[is][\color{Sepia}]{SUS}{EUS},
moredelim=**[is][\color{black}]{SOK}{EOK},
% deletestring=[d]{"},
}
\lstset{morecomment=[n]{/*}{*/}}

\newcommand{\liv}[1]{\lstinline{#1}}
\newcommand{\li}[1]{\lstinline[basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont]{#1}}
\newcommand{\lismall}[1]{\lstinline[basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont]{#1}}
\newcommand{\lifootnote}[1]{\lstinline[basicstyle=\ttfamily\fontsize{7pt}{1em}\selectfont]{#1}}


%% Joshua Dunfield macros
\def\OPTIONConf{1}%
\usepackage{joshuadunfield}

%% Can remove this eventually
\usepackage{blindtext}

\usepackage{enumitem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Matt says: Cyrus, this package `adjustbox` seems directly related
%% to the `clipbox` error; To get rid of the error, I moved it last
%% (after other usepackages) and I added the line just above it, which
%% permits it to redefine `clipbox` (apparently also defined in
%% `pstricks`, and due to latex's complete lack of namespace
%% management, these would otherwise names clash).
\let\clipbox\relax
\usepackage[export]{adjustbox}% http://ctan.org/pkg/adjustbox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{draftwatermark}
%\SetWatermarkText{DRAFT}
%\SetWatermarkScale{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% A macro for the name of the system being described by ``this paper''
\newcommand{\HazelnutLive}{\textsf{Hazelnut Live}\xspace}
\newcommand{\Hazelnut}{\textsf{Hazelnut}\xspace}
% The mockup, work-in-progress system.
\newcommand{\Hazel}{\textsf{Hazel}\xspace}

% \newtheorem{theorem}{Theorem}[chapter]
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{corollary}[theorem]{Corollary}
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{assumption}[theorem]{Assumption}
% \newtheorem{condition}[theorem]{Condition}

\newtheoremstyle{slplain}% name
  {.15\baselineskip\@plus.1\baselineskip\@minus.1\baselineskip}% Space above
  {.15\baselineskip\@plus.1\baselineskip\@minus.1\baselineskip}% Space below
  {\slshape}% Body font
  {\parindent}%Indent amount (empty = no indent, \parindent = para indent)
  {\bfseries}%  Thm head font
  {.}%       Punctuation after thm head
  { }%      Space after thm head: " " = normal interword space;
        %       \newline = linebreak
  {}%       Thm head spec
\theoremstyle{slplain}
\newtheorem{thm}{Theorem}  % Numbered with the equation counter
\numberwithin{thm}{section}
\newtheorem{defn}[thm]{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
% \newtheorem{cor}[section]{Corollary}     
% \newtheorem{lem}[section]{Lemma}         
% \newtheorem{prop}[section]{Proposition}  

% \setlength{\abovedisplayskip}{0pt}
% \setlength{\belowdisplayskip}{0pt}
% \setlength{\abovedisplayshortskip}{0pt}
% \setlength{\belowdisplayshortskip}{0pt}



\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2018}
\acmMonth{3}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
% \acmConference[]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}

\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


\fancyfoot{} % suppresses the footer (also need \thispagestyle{empty} after \maketitle below)


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\input{commands}
\input{macros}

\setlength{\abovecaptionskip}{4pt plus 3pt minus 2pt} % Chosen fairly arbitrarily
\setlength{\belowcaptionskip}{-4pt plus 3pt minus 2pt} % Chosen fairly arbitrarily


\begin{document}

%% Title information
\title{Relit: Implementing Typed Literal Macros in Reason}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
% \titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
% \subtitle{Subtitle}                     %% \subtitle is optional
% \subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Charles Chamberlain}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Chicago}            %% \institution is required
  % \streetaddress{Street1 Address1}
  % \city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  % \country{Country1}
}
\email{cchamberlain@uchicago.edu}          %% \email is recommended

\author{Cyrus Omar}
% \authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  % \position{Position1}
  % \department{Department1}              %% \department is recommended
  \institution{University of Chicago}            %% \institution is required
  % \streetaddress{Street1 Address1}
  % \city{City1}
  % \state{State1}
  % \postcode{Post-Code1}
  % \country{Country1}
}
\email{comar@cs.uchicago.edu}          %% \email is recommended

% %% Author with two affiliations and emails.
% \author{First2 Last2}
% \authornote{with author2 note}          %% \authornote is optional;
%                                         %% can be repeated if necessary
% \orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
% \affiliation{
%   \position{Position2a}
%   \department{Department2a}             %% \department is recommended
%   \institution{Institution2a}           %% \institution is required
%   \streetaddress{Street2a Address2a}
%   \city{City2a}
%   \state{State2a}
%   \postcode{Post-Code2a}
%   \country{Country2a}
% }
% \email{first2.last2@inst2a.com}         %% \email is recommended
% \affiliation{
%   \position{Position2b}
%   \department{Department2b}             %% \department is recommended
%   \institution{Institution2b}           %% \institution is required
%   \streetaddress{Street3b Address2b}
%   \city{City2b}
%   \state{State2b}
%   \postcode{Post-Code2b}
%   \country{Country2b}
% }
% \email{first2.last2@inst2b.org}         %% \email is recommended


%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
% \thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\input{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
% \begin{CCSXML}
% <ccs2012>
% <concept>
% <concept_id>10011007.10011006.10011008</concept_id>
% <concept_desc>Software and its engineering~General programming languages</concept_desc>
% <concept_significance>500</concept_significance>
% </concept>
% <concept>
% <concept_id>10003456.10003457.10003521.10003525</concept_id>
% <concept_desc>Social and professional topics~History of programming languages</concept_desc>
% <concept_significance>300</concept_significance>
% </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Software and its engineering~General programming languages}
% \ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
% \keywords{keyword1, keyword2, keyword3}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle
\thispagestyle{empty} % suppresses the footer

\section{Motivation}

The Reason project (\url{https://reasonml.github.io/}) is experiencing growing adoption by focusing on increasing the \emph{syntactic familiarity} of OCaml (from the perspective of the broader developer community) without changing its semantics. The focus of the Reason effort so far has been on the syntax of the primitive constructs of OCaml. An additional way to increase syntactic familiarity is by introducing new {literal forms} for constructing and pattern matching on  common user-defined data structures. For example, both OCaml and Reason include literal forms for lists, e.g. \li{[e1, e2, e3]}. By comparison, explicit constructors, e.g. \li{Nil} and \li{Cons}, is less concise and less familiar to humans.

The problem is that there are an  unbounded number of other user-defined data structures that could benefit from literal notation. Although Reason does include a few more literal notations than OCaml, e.g. it supports ``JSX literals'' which are based on HTML, it would be infeasible for Reason to attempt to build in all possibly-useful literal notations \emph{a priori}. Instead, there has been a need for a reasonable mechanism that allows ordinary library providers to define new literal notation.

For example, consider the recursive datatype \li{Regex.t}, defined in Fig.~\ref{fig:Regex-module-def}, which encodes simple regular expressions (regexes). Although this encoding is semantically useful, the induced notation is syntactically verbose and unfamiliar. For example, we would construct a regex that matches the strings \li{"A"}, \li{"T"}, \li{"G"} or \li{"C"}, which represent the four bases in DNA, as follows:
\begin{lstlisting}[numbers=none]
module DNA = { let any = Regex.(Or(S "A", Or(S "T", Or(S "G", Or(S "C"))))) }
\end{lstlisting}
From there, we might define a regular expression that matches the DNA sequences recognized by the BisA restriction enzyme---\li{GC}$X$\li{GC}, where $X$ is any of these four bases---as follows:
\begin{lstlisting}[numbers=none]
  let bisA = Regex.(Seq(S "G", Seq(S "C", 
                    Seq(DNA.any_base, Seq(S "G", S "C")))))
\end{lstlisting}

These examples would be more concise and familiar if we built regex literals into Reason, based on the POSIX standard regular expression notation extended with support for constructing regexes compositionally by splicing in expressions of type \li{Regex.t} delimited by \li{$(} and \li{)}:
\begin{lstlisting}[numbers=none]
  module DNA = { let any_base = `(SURLA|T|G|CEURL)` };
  let bisA = `(SURLGC$(EURLDNA.any_baseSURL)GCEURL)`
\end{lstlisting}
\noindent
However, building in regex notation is \emph{ad hoc} because there are dozens of other examples of notation in programming, mathematics and science that could similarly benefit. 


\begin{figure}[t]
\begin{subfigure}[t]{0.45\textwidth}
\vspace{-1px}
\begin{lstlisting}[mathescape=~]
  module Regex = {
    type t = 
      | Empty
      | AnyChar 
      | S(string)
      | Seq(t, t) 
      | Or(t, t) 
      | Star(t);
  }
\end{lstlisting}
\vspace{-5px}
\caption{The \li{Regex} module, which defines the recursive datatype \li{Regex.t}.}
\label{fig:Regex-module-def}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.53\textwidth}
\vspace{-1px}
\begin{lstlisting}[mathescape=|]
  module RegexNotation = {
    notation $regex at Regex.t {
      lexer  RegexLexer  
      parser RegexParser.start
      in package regex_parser;
      dependencies = 
        { module Regex = Regex; }
    }
  }
\end{lstlisting}
\vspace{-5px}
\caption{The definition of the \li{$regex} TLM (the lexer and parser is detailed in \cite{TLMs-paper}).}
\label{fig:regex-tlm-def}
\end{subfigure}

\begin{subfigure}[t]{\textwidth}
\vspace{5px}
\begin{lstlisting}
  notation $regex = RegexNotation.$regex; /* or open RegexNotation */
  module DNA = { let any_base = $regex `(SURLA|T|G|CEURL)`; };
  let bisA = $regex `(SURLGC$(EURLDNA.any_baseSURL)GCEURL)`;
\end{lstlisting}
\vspace{-4px}
\caption{Examples of the \li{$regex} TLM being applied in a bioinformatics application. %In each case, literal body, between backticks, is initially left unparsed according to the language's context-free syntax. %The applied TLM determines a segmentation and expansion during the typed expansion phase, which generalizes the usual typing phase.
}
\label{fig:first-tlm-example}
\end{subfigure}
\vspace{3px}
\caption{Case Study (reproduced from \cite{TLMs-paper}): POSIX-style regex literal notation, with support for regex splicing.}
\vspace{-4px}
\label{fig:regex-case-study}
\end{figure}

An existing alternative is to use a tool like \li{camlp4} or \li{ppx} to introduce this sort of literal notation modularly. However, there are several problems with these tools. To address these problems, \citet{TLMs-paper} introduced \emph{typed literal macros (TLMs)}, which, unlike these prior tools, allow programmers to reason abstractly---without looking at the underlying expansion or the parser---about (1) which extension is uniquely responsible for each form, (2) the type of each literal, and each spliced expression within the literal, and (3) where variables are bound (i.e. TLMs are hygienic).

An example of a TLM definition for regex notation, named \li{$regex}, is given in Fig.~\ref{fig:regex-tlm-def}. We apply the \li{$regex} TLM to two different literal forms express 
the example just given in Fig.~\ref{fig:first-tlm-example}. Each TLM is responsible for parsing the literal body to which it is applied to generate an expansion, i.e. an OCaml parse tree. The system validates each generated expansion to provide the strong abstract reasoning principles just mentioned. These reasoning principles are examined in formal detail in the paper by \citet{TLMs-paper}, which will be presented by Cyrus at ICFP. The purpose of the proposed talk, which will be given by Charles, will be to provide a complementary ``deep dive'' that describes how we integrated this mechanism for Reason without modifying the OCaml compiler itself, by making creative use of several existing components of the OCaml system, including the \li{ppx} preprocessor system, the \li{compiler-libs} package, \li{ocamlfind}, \li{ocamldep} and the module system. These implementation aspects are detailed only superficially in the ICFP paper.


\section{Implementation Overview}

We have modified the Reason parser to support the syntax for defining a new notation, seen in Fig.~\ref{fig:regex-tlm-def}, and the TLM quotation syntax, either \li{Path.To.$regex `(body)`} or \li{`(body)`} (which is used for implicit TLM application, see \cite{TLMs-paper}). The literal body can have matching occurrences of \li{`(} and \li{)`} (much like comments in Reason/OCaml), but is otherwise unconstrained.

The \li{$regex} TLM definition in Fig.~\ref{fig:regex-tlm-def} desugars to the following OCaml module:
\begin{lstlisting}
    module RelitInternalDefn_regex = struct
      type t = Regex.t (* corresponds to "at Regex.t" *)
      module Lexer_RegexLexer = struct end (* ... "lexer RegexLexer" *)
      module Parser_RegexParser = struct end (* ... "parser RegexParser" *)
      module Nonterminal_start = struct end (* ... ".start" *)
      module Package_regex_parser = struct end (* ... "in package regex_parser" *)
      module Dependencies = struct (* ... "dependencies = {" *)
        module Regex = Regex
      end
      exception Apply of string * string (* used internally, see below *)
    end
\end{lstlisting}

The name of the TLM is stored as the module name, with the internal prefix \li{RelitInternalDefn_}. By encoding TLM definitions as modules, TLMs can be packaged inside other modules (\li{RegexNotation} in Fig.~\ref{fig:regex-tlm-def}) and it is straightforward to support scoped TLM abbreviations, as on Line 1 of Fig.~\ref{fig:first-tlm-example}. By encoding the relevant information from the TLM definition in module names, e.g. \li{Lexer_RegexLexer} and \li{Nonterminal_start}, we ensure that the corresponding signature is a \emph{singleton signature}, i.e. it uniquely identifies the TLM definition, so TLM definitions can be included in module signatures, exported from functors and packaged using the standard tooling.

A TLM application is represented internally as follows:
\begin{lstlisting}[numbers=none]
  raise (RelitInternalDefn_regex.Apply
          ("You're using relit syntax without the relit ppx!", "A|T|G|C") [@relit])
\end{lstlisting}

In order to expand the literal body, here \li{"A|T|G|C"}, we must be able to resolve the signature of the \li{RelitInternalDefn_regex} module. In other words, we must be able to typecheck before expanding literal bodies. This is why we encode a TLM application as raising an exception. Raised exceptions match against any type, so it will typecheck without an issue before it is expanded fully. Note that this occasionally results in a less specific type error message than the user would otherwise see. 

Once the Relit PPX has all the information for a given TLM application site that it needs, it must run the lexer and parser on the literal body (still at compile-time).  The lexer and parser must be generated by, or have the same interface as the modules generated by, \li{ocamllex} and Menhir, respectively. Our first attempt involved starting an OCaml toplevel within the PPX, \li{#load}-ing the appropriate OCaml object files, and then evaluating a call to the parser. This proved difficult when the parser and lexer themselves had dependencies. Instead, we require that the parser and lexer be in their own \li{ocamlfind} package, specified in the \li{notation} syntax (here, \li{regex_parser}). We then call into \li{ocamlfind ocamlc} internally to ensure that the dependencies are correctly loaded.

After running the provided parser against the literal body, we are left with a \emph{proto-expansion}---an OCaml parse tree where splices are represented abstractly, i.e. they have not yet been expanded. Before expanding the splices, we first check to make sure the proto-expansion is well-typed and context independent: it must not refer to variables, types, or modules from the application site's typing context. Instead, only the types and modules explicitly mentioned in the \li{dependencies} of the TLM, plus the OCaml pervasives, are available to the proto-expansion. In principle, it should be straightforward to enforce this constraint by typechecking against an empty context extended with the dependencies. However, the OCaml \li{compiler-libs} package does not directly support this functionality because adding the dependencies to the empty typing context exposes the global modules of all packages that the dependencies transitively depend on. 
Consequently, we first typecheck against this overly permissive typing context, which ensures, at least, that there are no dependencies on non-global bindings. Then, we write the parse tree to a temporary file, and run \li{ocamldep -modules} against the file. This gives us the list of free modules, which we check explicitly against the dependencies, resulting in a completely context independent proto-expansion.

We can then consider splices. Internally, an encoded splice that says characters 2 through 8 of the literal body should be parsed as an unexpanded expression of type \li{string} looks like this:
\begin{lstlisting}[numbers=none]
  raise (ignore (2, 8) ; Failure "RelitInternal__Spliced") : string
\end{lstlisting}
Notice again that we used an exception to ensure that the typechecker can run, as just described. 

The PPX collects all the splices in a proto-expansion, checks that the segments are non-overlapping, and parses the corresponding subsequence of the literal body using our extended Reason parser. One might think that these resulting splice parse trees could then replace the splice reference in the proto-expression, but that would allow the TLM to introduce bindings into the splices. Instead, we want to maintain a capture avoidance property, so we replace each encoded splice with a fresh variable, construct a lambda that abstracts over those variables, and immediately apply this lambda to the corresponding splice parse trees. The resulting expansion is of the following form:
\begin{lstlisting}
  ((fun a b c -> (* ... proto-expansion with variables instead of splices ... *)) 
    splice1 splice2 splice3)
\end{lstlisting}

The last step is to repeat the entire process so as to recursively expand any TLM applications exposed by this first phase of expansion, stopping if there are no remaining TLM applications.

\section{Conclusion}
By encoding TLM definitions as modules with singleton signatures, and TLM applications and spliced expressions using exceptions, we have been able to implement a powerful macro system for Reason using the OCaml PPX system and other existing tooling, rather than by extending the OCaml compiler itself (as in previous proposals for OCaml macros \cite{modular-macros}). TLM definitions follow the same scoping structure as modules. Our evolving implementation is available from \url{https://github.com/cyrus-/relit} (by the time of the workshop, we plan to have an initial beta available with improved error reporting and more conveniences, examples and documentation). 

% \citet{TLMs-paper} also developed TLMs for patterns, in addition to expressions. Implementing pattern TLMs requires a bit more creativity because we cannot raise exceptions directly in patterns. Instead, we must replace the expression that the pattern presides over with an exception. 

We think TLMs would be useful when using ``normal'' OCaml syntax too. The main issue here is that every TLM must then be able to support both syntaxes within splices. To achieve this, we plan to use Menhir's support for parameterized parsers to pass in syntax-agnostic versions of the helper functions that support  splicing.

There are also several remaining questions that have to do with integration with other components of OCaml's tooling. Although Menhir has basic support for TLMs, we need to add support for highlighting spliced segments differently, and we would like for the programmer to be able to request the type of the spliced segment under the cursor. Another difficulty has to do with \li{ocamldep}, which cannot see inside spliced expressions in a context-free manner to extract dependencies. We plan to use the recently added support for \li{ppx} extensions in \li{ocamldep} to eliminate this restriction, but this is non-trivial due to the need to be able to typecheck the unexpanded program. Some build systems, notably \li{jbuilder}, currently limit \li{ppx} extensions from being able to access compiler flags in a manner that causes problems for Relit. We currently only test with \li{rebuild}/\li{ocamlbuild}.

Overall, we believe that our experiences developing Relit, which in many ways ``stress tested'' the PPX system, will be of interest to others working to improve OCaml's tooling, and we believe that Relit itself is an interesting new mechanism of interest to the OCaml community. 


%\clearpage
\bibliography{papers,all.short,hazel_NSF,references}

% \clearpage
% \appendix
% \input{implementation-appendix}

\end{document}
